<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Semaine 8 on INF 6450 - Gestion de l'information avec XML</title><link>https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/</link><description>Recent content in Semaine 8 on INF 6450 - Gestion de l'information avec XML</description><generator>Hugo</generator><language>fr</language><atom:link href="https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction au XSLT</title><link>https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/introduction_au_xslt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/introduction_au_xslt/</guid><description>&lt;h1&gt;
 Introduction au XSLT
&lt;/h1&gt;
&lt;h2&gt;
 Qu'est-ce que le XSLT
&lt;/h2&gt;
&lt;p&gt;
 La première version du langage XSLT (
 &lt;i&gt;
 Extensible Stylesheet Language Transformation
 &lt;/i&gt;
 )
 a été publiée en 1997 et elle est devenue une recommandation W3C en 1999.
 Elle fait partie du XSL (
 &lt;i&gt;
 Extensible Stylesheet Language
 &lt;/i&gt;
 ) qui comprend une seconde composante,
 les XSL-FO (
 &lt;i&gt;
 Extensible Stylesheet Language Formatting Objects
 &lt;/i&gt;
 ).
 La technologie XSL tire son origine du besoin d'un langage simple, mais suffisamment puissant
 pour pouvoir contrôler finement l'affichage du XML. On utilise beaucoup le XSLT sur le web et au sein
 des systèmes d'information, alors que le XSL-FO est davantage utile pour les applications
 de mise en page spécialisées. Dans ce cours, nous nous soucierons seulement du XSLT, dont l'utilité
 dépasse de loin les problèmes de présentation.
&lt;/p&gt;</description></item><item><title>XSLT en ligne</title><link>https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/xslt_en_ligne/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/xslt_en_ligne/</guid><description>&lt;h1 style="font-size: 2rem; font-weight: bold; color: #1f2937; text-align: center; margin-bottom: 1.5rem;"&gt;
 XSLT en ligne
&lt;/h1&gt;
&lt;p style="color: #4b5563; margin-bottom: 1rem; line-height: 1.5;"&gt;
 Testez vos transformations XSLT directement dans votre navigateur ! Cet outil vous permet de traiter n'importe quel fichier XML avec une feuille de style XSLT sans utiliser l'instruction
 &lt;code style="background-color: #f3f4f6; padding: 2px 4px; border-radius: 4px; font-family: monospace;"&gt;
 xml-stylesheet
 &lt;/code&gt;
 . C'est une alternative pratique pour programmer et expérimenter avec XSLT sans charger de fichiers externes.
&lt;/p&gt;</description></item><item><title>Un peu plus de XSLT : fonctionnement de base, template et value-of</title><link>https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/un_peu_plus_de_xslt_fonctionnement_de_base_template_et_value-of/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/un_peu_plus_de_xslt_fonctionnement_de_base_template_et_value-of/</guid><description>&lt;h1&gt;
 Un peu plus de XSLT : fonctionnement de base, template et value-of
&lt;/h1&gt;
&lt;h2 class="recall"&gt;
 « Éléments xsl:template »
&lt;/h2&gt;
&lt;p&gt;
 Modifions maintenant le fichier « xslt.xml » de façon à rendre l'expérience plus intéressante. 
 Tout d'abord, traitons tous les éléments « facture » du document XML. 
 Pour obtenir le résultat, il faut placer un élément « &amp;lt;xsl:template match="facture"&amp;gt; » 
 dans l'élément-racine du document XSLT comme ceci :
&lt;/p&gt;
&lt;p style="border:solid 1px black;white-space:pre; font-size:0.85em"&gt;
 &amp;lt;?xml version="1.0" encoding="ISO-8859-1"?&amp;gt;
 &amp;lt;xsl:stylesheet version="1.0" 
 xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&amp;gt;
 &amp;lt;xsl:template match="facture"&amp;gt;
 On doit mettre quelque chose ici!!!
 &amp;lt;/xsl:template&amp;gt;
 &amp;lt;/xsl:stylesheet&amp;gt;
&lt;/p&gt;</description></item><item><title>Les valeurs d’attribut</title><link>https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/les_valeurs_dattribut/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/les_valeurs_dattribut/</guid><description>&lt;h1 id="les-valeurs-dattribut"&gt;
 Les valeurs d’attribut
 &lt;a class="anchor" href="#les-valeurs-dattribut"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;h2 id="spécifier-les-valeurs-dattributs"&gt;
 Spécifier les valeurs d&amp;rsquo;attributs
 &lt;a class="anchor" href="#sp%c3%a9cifier-les-valeurs-dattributs"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Nous savons maintenant comment aller chercher la valeur d&amp;rsquo;un attribut en utilisant une expression XPath contenant le symbole « @ ». Cependant, qu&amp;rsquo;en est-il de la spécification des valeurs d&amp;rsquo;attributs? Supposons le document suivant :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-xml" data-lang="xml"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#0550ae"&gt;&amp;lt;facture&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#0550ae"&gt;&amp;lt;montant&amp;gt;&lt;/span&gt;10.10&lt;span style="color:#0550ae"&gt;&amp;lt;/montant&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#0550ae"&gt;&amp;lt;/facture&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Nous voulons le simplifier pour n&amp;rsquo;avoir que :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-xml" data-lang="xml"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#0550ae"&gt;&amp;lt;facture&lt;/span&gt; &lt;span style="color:#1f2328"&gt;montant=&lt;/span&gt;&lt;span style="color:#0a3069"&gt;&amp;#34;10.10&amp;#34;&lt;/span&gt; &lt;span style="color:#0550ae"&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Nous pouvons obtenir ce résultat en utilisant les accolades, pour indiquer une valeur XPath comme valeur d&amp;rsquo;attribut, de la façon suivante :&lt;/p&gt;</description></item><item><title>XSLT modulaire</title><link>https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/xslt_modulaire/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/xslt_modulaire/</guid><description>&lt;h1&gt;
 XSLT modulaire
&lt;/h1&gt;
&lt;h2&gt;
 Modularité avec les éléments « xsl:apply-templates »
&lt;/h2&gt;
&lt;p&gt;
 Notre fichier « xslt.xml » se complexifie et devient 
 plus difficile à comprendre. Tout est dans un seul modèle, le modèle
 &lt;i&gt;
 facture
 &lt;/i&gt;
 . 
 Pour simuler un problème probable, imaginons que notre XML est plus complexe et prend la forme :
&lt;/p&gt;
&lt;p style="border:solid 1px black;white-space:pre; font-size:0.85em"&gt;
 &amp;lt;?xml version="1.0" encoding="ISO-8859-1" ?&amp;gt;
 &amp;lt;?xml-stylesheet href="xslt.xml" type="application/xml"?&amp;gt;
 &amp;lt;facture&amp;gt;
 &amp;lt;montant&amp;gt;10.10&amp;lt;/montant&amp;gt;
 &amp;lt;recipiendaire&amp;gt;
 &amp;lt;personne&amp;gt;
 &amp;lt;sexe&amp;gt;M&amp;lt;/sexe&amp;gt;
 &amp;lt;nom&amp;gt;Rochond&amp;lt;/nom&amp;gt;
 &amp;lt;prenom&amp;gt;Jean&amp;lt;/prenom&amp;gt;
 &amp;lt;/personne&amp;gt;
 &amp;lt;/recipiendaire&amp;gt;
 &amp;lt;commercant&amp;gt;
 &amp;lt;personne&amp;gt;
 &amp;lt;sexe&amp;gt;F&amp;lt;/sexe&amp;gt;
 &amp;lt;nom&amp;gt;Ladouce&amp;lt;/nom&amp;gt;
 &amp;lt;prenom&amp;gt;Jeanne&amp;lt;/prenom&amp;gt;
 &amp;lt;/personne&amp;gt;
 &amp;lt;/commercant&amp;gt;
 &amp;lt;raison&amp;gt;Achat d'ordinateur&amp;lt;/raison&amp;gt;
 &amp;lt;/facture&amp;gt;
&lt;/p&gt;</description></item><item><title>Les noms d’éléments</title><link>https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/les_noms_delements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/les_noms_delements/</guid><description>&lt;h1&gt;
 Les noms d’éléments
&lt;/h1&gt;
&lt;h2 class="recall"&gt;
 Capturer le nom d'un élément
&lt;/h2&gt;
&lt;p&gt;
 Supposons que nous voulions afficher uniquement les noms des éléments (sans
 leur contenu). Nous pouvons
 obtenir ce résultat avec la fonction XPath « name » qui donne le
 nom de l'élément.
 La fonction name inclut le préfixe de l'espace de noms. Si on souhaite le
 nom de l'élément sans
 le préfixe, on peut utiliser la fonction « local-name ». La
 fonction
 « namespace-uri » donne l'URI de l'espace de noms de l'élément.
&lt;/p&gt;</description></item><item><title>Attribut mode</title><link>https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/attribut_mode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/attribut_mode/</guid><description>&lt;h1&gt;
 Attribut mode
&lt;/h1&gt;
&lt;h2&gt;
 Utilisation de l'attribut « mode »
&lt;/h2&gt;
&lt;p&gt;
 Il arrive que nous voulions définir plus d'un modèle pour un élément donné.
 Nous pouvons ajouter des modèles en utilisant l'attribut « mode »
 qui s'applique aux
 éléments « xsl:apply-templates » et « xsl:template ». La
 règle est très simple :
 si votre élément « xsl:apply-templates » a une valeur d'attribut
 pour « mode », alors
 seuls les éléments « xsl:template » ayant la même valeur
 d'attribut pour « mode » s'appliquent.
 On utilise souvent l'attribut « mode » pour faire des tables des
 matières.
&lt;/p&gt;</description></item><item><title>La fonction generate-id</title><link>https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/la_fonction_generate-id/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/la_fonction_generate-id/</guid><description>&lt;h1 class=""&gt;
 La fonction generate-id
&lt;/h1&gt;
&lt;h2 class="recall"&gt;
 Fonction « generate-id »
&lt;/h2&gt;
&lt;p&gt;
 La fonction XSLT « generate-id » génère un « nom » unique
 pour chaque élément d'un document XML.
 Ce nom sera toujours le même pour un même élément, même si nous le
 rencontrons à plusieurs reprises.
 Si nous reprenons la liste des cours de l'exemple précédent sur
 l'utilisation de l'attribut « mode »,
 nous pourrions générer un identifiant unique pour chaque cours et l'afficher
 comme dans l'exemple de document XSLT qui suit :
&lt;/p&gt;</description></item><item><title>Les tests</title><link>https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/les_tests/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/les_tests/</guid><description>&lt;h1 class=""&gt;
 Les tests
&lt;/h1&gt;
&lt;h2 class="recall"&gt;
 Utilisation des tests
&lt;/h2&gt;
&lt;p&gt;
 Nous pouvons tester des conditions à l'aide d'expressions XPath contenant
 les symboles « &amp;lt; », « = », « != »,
 « or », « and », « &amp;gt; »,
 « &amp;gt;= », « &amp;lt;= ».
 Nous utilisons les tests en XSLT avec les éléments « xsl:choose »
 et « xsl:if ».
 Par exemple, faire quelque chose de particulier, si le nom de l'élément
 courant est « montant ».
&lt;/p&gt;</description></item><item><title>Les boucles</title><link>https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/les_boucles/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/les_boucles/</guid><description>&lt;h1 class=""&gt;
 Les boucles
&lt;/h1&gt;
&lt;h2 class="recall"&gt;
 Utiliser XSLT comme base de données et éléments
 « for-each »
&lt;/h2&gt;
&lt;p&gt;
 L'exemple de la liste des clients avec leur numéro de téléphone nous permet
 de faire plus. Tout d'abord, l'expression « //client » donne une
 séquence de tous les éléments « client »
 dans le nœud courant.
 Avec l'expression XPath « //client[nom='Sylvain'] », nous pouvons
 obtenir la séquence de tous les
 éléments « client » ayant pour nom « Sylvain ». Dans ce
 cas précis, il y a plus d'un élément
 dans la réponse. Pour visiter l'ensemble des éléments dans la séquence,
 il suffit d'utiliser l'élément « xsl:for-each » comme ceci :
&lt;/p&gt;</description></item><item><title>Clés et aggrégation</title><link>https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/cles_et_aggregation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lemire.github.io/inf6450-hugo/docs/semaines/semaine_8/cles_et_aggregation/</guid><description>&lt;h1 class=""&gt;
 Clés et aggrégation
&lt;/h1&gt;
&lt;h2 class="recall"&gt;
 Obtenir l'aggrégation avec la fonction
 « generate-id »
&lt;/h2&gt;
&lt;p&gt;
 Supposons qu'on veuille calculer le total des
 éléments « quantite », mais en faisant l'aggrégation
 pour chaque valeur de l'attribut « type » dans l'exemple suivant.
&lt;/p&gt;
&lt;p style="border:solid 1px black;white-space:pre; font-size:0.85em"&gt;
 &amp;lt;?xml version="1.0" encoding="ISO-8859-1"?&amp;gt;
 &amp;lt;?xml-stylesheet href="produits.xsl" type="text/xsl" ?&amp;gt;
 &amp;lt;produits&amp;gt;
 &amp;lt;france&amp;gt;
 &amp;lt;quantite type="bain"&amp;gt;53&amp;lt;/quantite&amp;gt;
 &amp;lt;quantite type="chambre"&amp;gt;12&amp;lt;/quantite&amp;gt;
 &amp;lt;/france&amp;gt;
 &amp;lt;canada&amp;gt;
 &amp;lt;quantite type="bain"&amp;gt;14&amp;lt;/quantite&amp;gt;
 &amp;lt;quantite type="chambre"&amp;gt;12&amp;lt;/quantite&amp;gt;
 &amp;lt;/canada&amp;gt;
 &amp;lt;/produits&amp;gt;
&lt;/p&gt;
&lt;p&gt;
 On pourrait tenter de résoudre ce problème avec une expression
 XPath de la forme « sum(//quantite[@type=current()/@type]) ».
 Malheureusement, on risque
 alors de calculer plusieurs fois la même somme. Par exemple, tentez
 d'appliquer
 la transformation suivante :
&lt;/p&gt;</description></item></channel></rss>